/**
 * Source Code, High Level Architecture Documentation and Common Criteria
 * Documentation Copyright (C) 2013 and ownership belongs to The Norwegian
 * Ministry of Local Government and Regional Development and Scytl Secure
 * Electronic Voting SA ("Licensor").
 *
 * The Norwegian Ministry of Local Government and Regional Development has the
 * right to use, modify (whether by itself or by the use of contractors) and
 * copy the software for the sole purposes of performing Norwegian Public Sector
 * Elections, including to install and run the code on the necessary number of
 * locations centrally and in any number of counties and municipalities, and to
 * allow access to the solution from anywhere in the world by persons who have
 * the right to participate in Norwegian national or local elections. This also
 * applies to elections to the Longyearbyen Community Council at Svalbard and
 * any possible future public elections in Norway arranged by the Election
 * Authorities.
 *
 * Patents, relevant to the software, are licensed by Scytl Secure Electronic
 * Voting SA to the Norwegian Ministry of Local Government and Regional
 * Development for the purposes set out above.
 *
 * Scytl Secure Electronic Voting SA (or whom it appoints) has the right, inside
 * and outside of Norway to use, copy, modify and enhance the materials, as well
 * as a right of licensing and transfer, internally and externally, either by
 * itself or with the assistance of a third party, as part of the further
 * development and customization of its own standard solutions or delivered
 * together with its own standard solutions.
 *
 * The Norwegian Ministry of Local Government and Regional Development and Scytl
 * Secure Electronic Voting SA hereby grant to you (any third party) the right
 * to copy, modify, inspect, compile, debug and run the software for the sole
 * purpose of testing, reviewing or evaluating the code or the system solely for
 * non-commercial purposes. Any other use of the source code (or parts of it)
 * for any other purpose (including but not limited to any commercial purposes)
 * by any third party is subject to Scytl Secure Electronic Voting SA's prior
 * written approval.
 */
package com.scytl.evote.protocol.integration.voting.model;

import com.scytl.evote.protocol.exceptions.FatalProtocolException;
import com.scytl.evote.protocol.integration.eraser.Erasable;
import com.scytl.evote.protocol.integration.eraser.Eraser;
import com.scytl.evote.protocol.integration.voting.parser.model.ElectionType;
import com.scytl.evote.protocol.params.ElGamalEncryptionValues;
import com.scytl.evote.protocol.signers.SchnorrSignature;
import com.scytl.evote.protocol.utilities.ObjBuilder;

import org.apache.commons.lang.ArrayUtils;

import java.io.Serializable;
import java.io.UnsupportedEncodingException;

import java.math.BigInteger;

import java.util.Arrays;


/**
 * The vote that is to be generated by the voter and sent to the Vote Collector
 * Service and the Return Code Generator.
 */
public final class VoteBean implements Serializable, KeepMembers, Erasable {
    protected static final String UTF_8 = "UTF-8";
    private static final long serialVersionUID = 1L;
    private final byte[] _encGamma;
    private byte[][] _encVoteOptValues;
    private byte[] _encVoteSig;
    private byte[] _voteZKProofSig;
    private String _voterId;
    private final String _electionId;
    private final String _electionEventId;
    private final String _contestId;
    private final long _ts;
    private String _authTokenId;
    private String _intTokenId;
    private String _certificate;
    private final String _environment;
    private final Integer _voteProcessOrder;
    private String _electionType;
    private ElGamalEncryptionValues _elGamalEncryptionValues;

    /**
     * Constructor. It should be called be the vote bean builder
     *
     * @param voteBeanBuilder
     *            container for the vote bean fields
     */
    private VoteBean(final VoteBeanBuilder voteBeanBuilder) {
        if (voteBeanBuilder._encGamma == null) {
            _encGamma = null;
        } else {
            _encGamma = voteBeanBuilder._encGamma.clone();
        }

        if (voteBeanBuilder._encVoteOptIDs != null) {
            _encVoteOptValues = voteBeanBuilder._encVoteOptIDs.clone();

            for (int row = 0; row < voteBeanBuilder._encVoteOptIDs.length;
                    row++) {
                _encVoteOptValues[row] = voteBeanBuilder._encVoteOptIDs[row].clone();
            }
        }

        if (voteBeanBuilder._encVoteSig != null) {
            _encVoteSig = voteBeanBuilder._encVoteSig.clone();
        }

        if (voteBeanBuilder._voteZKProofSig != null) {
            _voteZKProofSig = voteBeanBuilder._voteZKProofSig.clone();
        }

        _voterId = voteBeanBuilder._voterId;
        _electionId = voteBeanBuilder._electionId;
        _electionEventId = voteBeanBuilder._electionEventId;
        _contestId = voteBeanBuilder._contestId;
        _ts = voteBeanBuilder._ts;
        _authTokenId = voteBeanBuilder._authTokenId;
        _intTokenId = voteBeanBuilder._intTokenId;
        _certificate = voteBeanBuilder._certificate;
        _environment = voteBeanBuilder._environment;
        _voteProcessOrder = voteBeanBuilder._voteProcessOrder;
        setElectionType(voteBeanBuilder._electionType);

        if ((_encGamma != null) && (_encVoteOptValues != null)) {
            _elGamalEncryptionValues = new ElGamalEncryptionValues(_encGamma,
                    _encVoteOptValues);
        }
    }

    /**
     * @return Returns the encVoteOptIDs.
     */
    public ElGamalEncryptionValues getEncVoteOptValues() {
        return _elGamalEncryptionValues;
    }

    /**
     * @param encodedEncVoteOptValues
     */
    public void setEncVoteOptValues(final byte[][] encodedEncVoteOptValues) {
        if (encodedEncVoteOptValues != null) {
            _encVoteOptValues = encodedEncVoteOptValues.clone();

            for (int row = 0; row < encodedEncVoteOptValues.length; row++) {
                _encVoteOptValues[row] = encodedEncVoteOptValues[row].clone();
            }

            _elGamalEncryptionValues = new ElGamalEncryptionValues(_encGamma,
                    _encVoteOptValues);
        }
    }

    /**
     * @return Returns the encGamma.
     */
    public byte[] getEncGamma() {
        byte[] result = null;

        if (_encGamma != null) {
            result = _encGamma.clone();
        }

        return result;
    }

    /**
     * @return Returns the encVoteOptIDs.
     */
    public byte[][] getEncodedEncVoteOptValues() {
        byte[][] result = null;

        if (_encVoteOptValues != null) {
            result = _encVoteOptValues.clone();

            for (int row = 0; row < _encVoteOptValues.length; row++) {
                result[row] = _encVoteOptValues[row].clone();
            }
        }

        return result;
    }

    /**
     * @param encVoteSig
     *            The encVoteSig to set.
     */
    public void setEncVoteSig(final byte[] encVoteSig) {
        if (encVoteSig == null) {
            _encVoteSig = null;
        } else {
            _encVoteSig = encVoteSig.clone();
        }
    }

    /**
     * @return Returns the encVoteSig.
     */
    public byte[] getEncVoteSig() {
        byte[] result = null;

        if (_encVoteSig != null) {
            result = _encVoteSig.clone();
        }

        return result;
    }

    /**
     * @return Returns the voteZKProofSig.
     */
    public SchnorrSignature getVoteZKProofSig() {
        byte[] signature = "".getBytes();

        if (_voteZKProofSig != null) {
            signature = _voteZKProofSig;
        }

        return new SchnorrSignature(signature);
    }

    /**
     * @param encodedVoteZKProofSig
     */
    public void setVoteZKProofSig(final byte[] encodedVoteZKProofSig) {
        if (encodedVoteZKProofSig == null) {
            _voteZKProofSig = null;
        } else {
            _voteZKProofSig = encodedVoteZKProofSig.clone();
        }
    }

    /**
     * @return Returns the voteZKProofSig.
     */
    public byte[] getEncodedVoteZKProofSig() {
        byte[] result = null;

        if (_voteZKProofSig != null) {
            result = _voteZKProofSig.clone();
        }

        return result;
    }

    /**
     * @return Returns the voterId. (Use voterId of authToken)
     */
    @Deprecated
    public String getVoterId() {
        return _voterId;
    }

    /**
     * @param voterId
     */
    public void setVoterId(final String voterId) {
        _voterId = voterId;
    }

    /**
     * @return Returns the electionId.
     */
    public String getElectionId() {
        return _electionId;
    }

    /**
     * @return Returns the contestId.
     */
    public String getContestId() {
        return _contestId;
    }

    /**
     * @return Returns the ts.
     */
    public long getTs() {
        return _ts;
    }

    /**
     * @return Returns the authTokenId.
     */
    public String getAuthTokenId() {
        return _authTokenId;
    }

    /**
     * @param authTokenId
     */
    public void setAuthTokenId(final String authTokenId) {
        _authTokenId = authTokenId;
    }

    /**
     * @return Returns the intTokenId.
     */
    public String getIntTokenId() {
        return _intTokenId;
    }

    /**
     * @param intTokenId
     */
    public void setIntTokenId(final String intTokenId) {
        _intTokenId = intTokenId;
    }

    /**
     * @return Returns the electionEventId.
     */
    public String getElectionEventId() {
        return _electionEventId;
    }

    /**
     * @return Returns the certificate.
     */
    public String getCertificate() {
        return _certificate;
    }

    /**
     * @param certificate
     */
    public void setCertificate(final String certificate) {
        _certificate = certificate;
    }

    /**
     * @return Returns the environment.
     */
    public String getEnvironment() {
        return _environment;
    }

    /**
     * @return Returns the voteProcessOrder.
     */
    public Integer getVoteProcessOrder() {
        return _voteProcessOrder;
    }

    /**
     * @return Returns the electionType.
     */
    public String getElectionType() {
        return _electionType;
    }

    /**
     * @param electionType
     *            if the election type to be set is not valid it throws a
     *            FatalProtocolException
     */
    public void setElectionType(final String electionType) {
        _electionType = null;

        if (electionType != null) {
            for (ElectionType enumValue : ElectionType.values()) {
                if (enumValue.name().equalsIgnoreCase(electionType)) {
                    _electionType = electionType;

                    break;
                }
            }

            if (_electionType == null) {
                throw new FatalProtocolException(
                    "Problems to initialize the election type field. Invalid value[" +
                    electionType + "]");
            }
        }
    }

    /**
     * Return the VoteBean except signature and certificate as a byte array<br />
     * For a complete byte array see Votebean.toFullByteArray()
     *
     * @return
     */
    public byte[] toByteArray() {
        byte[] voteData = null;

        try {
            if (_encGamma != null) {
                voteData = ArrayUtils.addAll(voteData, _encGamma);
            }

            if (_encVoteOptValues != null) {
                for (int i = 0; i < _encVoteOptValues.length; i++) {
                    voteData = ArrayUtils.addAll(voteData, _encVoteOptValues[i]);
                }
            }

            voteData = ArrayUtils.addAll(voteData, _voterId.getBytes(UTF_8));

            voteData = ArrayUtils.addAll(voteData,
                    _electionEventId.getBytes(UTF_8));

            voteData = ArrayUtils.addAll(voteData, _electionId.getBytes(UTF_8));

            voteData = ArrayUtils.addAll(voteData, _contestId.getBytes(UTF_8));

            voteData = ArrayUtils.addAll(voteData,
                    String.valueOf(_ts).getBytes(UTF_8));

            voteData = ArrayUtils.addAll(voteData, _authTokenId.getBytes(UTF_8));

            voteData = ArrayUtils.addAll(voteData, _intTokenId.getBytes(UTF_8));

            voteData = ArrayUtils.addAll(voteData, _electionType.getBytes(UTF_8));
        } catch (UnsupportedEncodingException e1) {
            throw new FatalProtocolException(e1);
        }

        return voteData;
    }

    /**
     * Return the VoteBean as a byte array
     *
     * @return
     */
    public byte[] toFullByteArray() {
        byte[] voteData = null;

        try {
            voteData = ArrayUtils.addAll(voteData, toByteArray());

            if (_encVoteSig != null) {
                voteData = ArrayUtils.addAll(voteData, _encVoteSig);
            }

            voteData = ArrayUtils.addAll(voteData, _certificate.getBytes(UTF_8));
        } catch (UnsupportedEncodingException e1) {
            throw new FatalProtocolException(e1);
        }

        return voteData;
    }

    /**
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuffer result = new StringBuffer();
        result.append("Gamma[").append(new BigInteger(_encGamma))
              .append("] VoteOptions[");

        for (byte[] encVoteOptValue : _encVoteOptValues) {
            result.append(new BigInteger(encVoteOptValue)).append(",");
        }

        result.append("] VoterID[").append(_voterId).append("] ElectionEventID[")
              .append(_electionEventId).append("] ContestID[").append(_contestId)
              .append("] TS[").append(_ts).append("] AuthTokenID[")
              .append(_authTokenId).append("] IntTokenID[").append(_intTokenId)
              .append("] ElectionType[").append(_electionType)
              .append("] VoteSig[").append(Arrays.asList(_encVoteSig))
              .append("] Certificate[").append(_certificate).append("]");

        return result.toString();
    }

    /**
     * @see com.scytl.evote.protocol.integration.eraser.Erasable#erase()
     */
    @Override
    public void erase() {
        Eraser eraser = Eraser.getNewTransientEraser();
        eraser.erase(_encVoteOptValues);
        eraser.erase(_encVoteSig);
        eraser.erase(_voteZKProofSig);
    }

    /**
     * Implements the object builder of the builder design pattern.
     */
    public static class VoteBeanBuilder implements ObjBuilder<VoteBean> {
        private byte[] _encGamma;
        private byte[][] _encVoteOptIDs;
        private byte[] _encVoteSig;
        private byte[] _voteZKProofSig;
        private String _voterId;
        private String _electionId;
        private String _electionEventId;
        private String _contestId;
        private long _ts;
        private String _authTokenId;
        private String _intTokenId;
        private String _certificate;
        private String _environment;
        private Integer _voteProcessOrder;
        private String _electionType;

        /**
         * @param encGamma
         *            The encGamma to set.
         */
        public VoteBeanBuilder setEncGamma(final byte[] encGamma) {
            _encGamma = encGamma;

            return this;
        }

        /**
         * @param encVoteOptIDs
         *            The encVoteOptIDs to set.
         */
        public VoteBeanBuilder setEncVoteOptIDs(final byte[][] encVoteOptIDs) {
            _encVoteOptIDs = encVoteOptIDs;

            return this;
        }

        /**
         * @param encVoteSig
         *            The encVoteSig to set.
         */
        public VoteBeanBuilder setEncVoteSig(final byte[] encVoteSig) {
            _encVoteSig = encVoteSig;

            return this;
        }

        /**
         * @param voteZKProofSig
         *            The voteZKProofSig to set.
         */
        public VoteBeanBuilder setVoteZKProofSig(
            final SchnorrSignature voteZKProofSig) {
            return setVoteZKProofSig(voteZKProofSig.encode());
        }

        /**
         * @param voteZKProofSig
         *            The voteZKProofSig to set.
         */
        public VoteBeanBuilder setVoteZKProofSig(final byte[] voteZKProofSig) {
            _voteZKProofSig = voteZKProofSig;

            return this;
        }

        /**
         * @param voterId
         *            The voterId to set.
         */
        public VoteBeanBuilder setVoterId(final String voterId) {
            _voterId = voterId;

            return this;
        }

        /**
         * @param electionId
         *            The electionId to set.
         */
        public VoteBeanBuilder setElectionId(final String electionId) {
            _electionId = electionId;

            return this;
        }

        /**
         * @param electionEventId
         *            The electionEventId to set.
         */
        public VoteBeanBuilder setElectionEventId(final String electionEventId) {
            _electionEventId = electionEventId;

            return this;
        }

        /**
         * @param contestId
         *            The contestId to set.
         */
        public VoteBeanBuilder setContestId(final String contestId) {
            _contestId = contestId;

            return this;
        }

        /**
         * @param ts
         *            The ts to set.
         */
        public VoteBeanBuilder setTs(final long ts) {
            _ts = ts;

            return this;
        }

        /**
         * @param authTokenId
         *            The authTokenId to set.
         */
        public VoteBeanBuilder setAuthTokenId(final String authTokenId) {
            _authTokenId = authTokenId;

            return this;
        }

        /**
         * @param intTokenId
         *            The intTokenId to set.
         */
        public VoteBeanBuilder setIntTokenId(final String intTokenId) {
            _intTokenId = intTokenId;

            return this;
        }

        /**
         * @param certificate
         *            The certificate to set.
         */
        public VoteBeanBuilder setCertificate(final String certificate) {
            _certificate = certificate;

            return this;
        }

        /**
         * @param environment
         *            The environment to set.
         */
        public VoteBeanBuilder setEnvironment(final String environment) {
            _environment = environment;

            return this;
        }

        /**
         * @param voteProcessOrder
         *            The voteProcessOrder to set.
         */
        public VoteBeanBuilder setVoteProcessOrder(
            final Integer voteProcessOrder) {
            _voteProcessOrder = voteProcessOrder;

            return this;
        }

        /**
         * @param electionType
         *            The electionType to set.
         */
        public VoteBeanBuilder setElectionType(final String electionType) {
            _electionType = electionType;

            return this;
        }

        /**
         * Sets the ElGamal encryption values (gamma and voteOptionIds)
         */
        public VoteBeanBuilder setElGamalEncryptionValues(
            final ElGamalEncryptionValues elGamalEncryptionValues) {
            _encGamma = elGamalEncryptionValues.encodeGamma();
            _encVoteOptIDs = elGamalEncryptionValues.encodePhis();

            return this;
        }

        /**
         * @see com.scytl.evote.protocol.utilities.ObjBuilder#build()
         */
        @Override
        public VoteBean build() {
            return new VoteBean(this);
        }
    }
}
